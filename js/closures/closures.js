"use strict";
// дебаггер позволяет отследить каждый шаг в консоле браузера
// let number = 5;
// // debugger;

// function logNumber() {
//   let number = 4;
//   //   debugger;
//   console.log(number);
// }

// number = 6;

// logNumber();
// // debugger;

// number = 8;

// logNumber();

function createCounter() {
  //1 создается новая переменная createCounter в глобальной области выполнения и мы ей присваеваем выполнение какой-то функции.
  let counter = 0; // 3 в первую очередь будет создана переменная counter со значением undefined. После этого в этой ф-ции, в этом вызове ф-ции создаваться новая локальная и глобальная область выполнения(т.е. лексическое окружение). После того как counter создался в лексическом локальном окружении появилась переменная counter со значением 0. В глобальном пока что ничего не будет(возможно ссылка на increment, но она не особо важна так как там изначально будет undefined)

  const myFunction = function () {
    //4 в этих строках создается новая ф-ция. Изначально создается новая переменная myFunction, которая содержит значение undefined, а после в нее уже помещается значение функции
    counter = counter + 1; //сами внутренности этой ф-ции описаныв этих двух
    return counter; //строках. И вот здесь создается замыкание, которое является частью ф-ции, которая лежит в переменной myFunction. Это значит что, когда эта ф-ция будет вызвана она хранит ссылку на counter, т.е в лексическом окружении будет сохранена ссылка на эту переменную.
  };
  return myFunction; // 5 в этой строчке возвращается содержимое ф-ции. Локальная область выполнения, т.е внутренее лексическое окружение у этой ф-ции, будет уничтожено, потому что оно больше не нужно. Но наружу возвращаем описание этой ф-ции(что происходит внутри) и ее замыкание, т.е то на что она будет ссылатся
}
//Более простое описание всего происходящего выше. Это как рюкзак с переменными, которые были в области видимости во время ее создания. Т.е когда создавалась ф-ция myFunction она видела внешний counter со значением 0 и когда возвращаем ее куда-то наружу, она все равно продолжает хранить ссылочку на let counter = 0; Хотя внутренее лексическое окружение этой функции исчезло. И все это будет храниться в переменной increment, в том числе и замыкание.

const increment = createCounter(); // 2 создаем новую переменную increment, которая изначально будет undefined. Она помещается в глобальную область выполнения и дальше идет вызов ф-ции createCounter/ Так как это вызов мы возвращаемся в строки ф-ции createCounter
const c1 = increment(); // 6 создаем переменную с1 со значение undefined и дальше вызываем increment, для того чтобы что-то туда записать. В эту переменную запишется 1, так как ссылка на let counter = 0;  все еще существует
const c2 = increment(); //здесь будет 2, так как он перезаписывает значение коунтера 1
const c3 = increment(); // здесь 3

console.log(c1, c2, c3); // 1 2 3

//Задачка из собеса. Почему не можем обратиться к num?
// for (let i = 0; i < 9; i++) {
//   for (let j = 0; j < 9; j++) {
//     let num = 3;
//   }
//   console.log(num);
// }
